import { Component, ElementRef, ViewChild, Renderer2, HostBinding, Injectable, Injector, ComponentFactoryResolver, ViewContainerRef, Input, NgModule } from '@angular/core';
import { Subject, interval, BehaviorSubject } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NodeComponent {
    /**
     * @param {?} renderer
     * @param {?} elementRef
     */
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this._heading = '';
        this._isVisible = false;
        this._pageNumberAtTop = false;
        this.showHeading = true;
        // Get host properties to dynamically change.
        this.hostPosition = '';
        this.hostVisibility = 'hidden';
        // Dynamic styles.
        this.numberStyle = {};
        this.headingStyle = {};
        this.nodeStyle = {};
        this.hostStyle = {};
        this.defaultStyles = {
            hostStyle: {},
            contentStyle: {
                'height': '9em',
                'width': '200px',
                'fontSize': '11px',
                'wordSpacing': '2px',
                'textAlign': 'justify',
                'lineHeight': '1.1em',
                'leftAlignLast': 'justified'
            },
            headingStyle: {
                'font-size': '14px',
                'height': '25px'
            },
            numberStyle: {
                'font-size': '10px',
            }
        };
        this.overflowSubject = new Subject();
        this.overflow = /** @type {?} */ (this.overflowSubject);
        this.adding = false;
        this.finishing = false;
        this.trimming = false;
        this.count = 100;
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        // Some initialisation.
        this.dummyText = this.text;
        this.trimming = true;
        // We use the mutation observer to see when our dummy text change has happened.
        this.changes = new MutationObserver((mutations) => this.manageState());
        this.changes.observe(this.dummyDivRef.nativeElement, { attributes: true, childList: true, characterData: true });
        // Kick off the state machine here, but with a delay for the first node,
        // since the initial loading of the component causes some delay in other initialisation. (I think).
        setTimeout(() => {
            // Wait till index is resolved.
            // We need to pause for the first node since the loading is lazy?
            if (this.index >= 99) {
                setTimeout(() => this.manageState(), 200); // TODO: find a event driven method here.
            }
            else {
                // The following nodes do not need this delay.
                this.manageState();
            }
        });
    }
    /**
     * @return {?}
     */
    get dummyText() { return this.dummyDivRef.nativeElement.textContent; }
    /**
     * @param {?} content
     * @return {?}
     */
    set dummyText(content) { this.dummyDivRef.nativeElement.textContent = content; }
    /**
     * @return {?}
     */
    get isVisible() { return this._isVisible; }
    /**
     * @param {?} value
     * @return {?}
     */
    set isVisible(value) {
        this._isVisible = value;
        this.hostVisibility = 'visible';
    }
    /**
     * @return {?}
     */
    get index() { return this._index; }
    /**
     * @param {?} index
     * @return {?}
     */
    set index(index) {
        this.pageNumber = 100 - index;
        setTimeout(() => {
            this._index = Math.abs(index);
            this.renderer.setStyle(this.elementRef.nativeElement, 'z-index', index);
        });
    }
    /**
     * @return {?}
     */
    get width() { return parseInt(this.mask.nativeElement.style.width.replace(/\D/g, '')); }
    /**
     * @param {?} width
     * @return {?}
     */
    set width(width) { this.renderer.setStyle(this.mask.nativeElement, 'width', `${width}px`); }
    /**
     * @return {?}
     */
    get heading() { return this._heading; }
    /**
     * @param {?} heading
     * @return {?}
     */
    set heading(heading) {
        this._heading = heading === '' ? this._heading = ' ' : this._heading = heading;
        NodeComponent.headingChangedSubject.next();
    }
    /**
     * @return {?}
     */
    get pageNumberAtTop() { return this._pageNumberAtTop; }
    /**
     * @param {?} value
     * @return {?}
     */
    set pageNumberAtTop(value) {
        this._pageNumberAtTop = value;
        this.numberStyle['padding-bottom'] = this.pageNumberAtTop ? '0px' : `${this.padding}px`;
        this.numberStyle['padding-top'] = this.pageNumberAtTop ? `${this.padding}px` : '0px';
    }
    /**
     * @param {?} style
     * @return {?}
     */
    applyStyle(style) {
        this.nodeStyle = style.contentStyle ? this.convertStyleToPx(style.contentStyle) : this.convertStyleToPx(this.defaultStyles.contentStyle);
        this.numberStyle = style.numberStyle ? style.numberStyle : this.defaultStyles.numberStyle;
        this.hostStyle = style.hostStyle ? style.hostStyle : this.defaultStyles.hostStyle;
        // Let's manipulate the padding style that was added to manage top or bottom placed numbering.
        if (this.numberStyle.padding > '') {
            this.padding = parseInt(this.numberStyle.padding.replace(/\D/g, ''));
        }
        else {
            this.padding = 16;
        }
        this.numberStyle['padding-left'] = `${parseInt(this.nodeStyle.width.replace(/\D/g, '')) / 2}px`;
        this.headingStyle = style.headingStyle ? style.headingStyle : this.defaultStyles.headingStyle;
        this.headingStyle.width = this.nodeStyle.width;
        this.renderer.setStyle(this.elementRef.nativeElement, 'width', style.width);
        this.nodeStyle.overflow = 'hidden';
        this.width = parseInt(this.nodeStyle.width.replace(/\D/g, ''));
        if (this.isOverlaid) {
            this.hostPosition = 'absolute';
        }
    }
    /**
     * @param {?} style
     * @return {?}
     */
    convertStyleToPx(style) {
        /** @type {?} */
        let tempStyle = style;
        /** @type {?} */
        let fontSizeSuffix = tempStyle['fontSize'].replace(/[\d\.]/g, '');
        /** @type {?} */
        let fontSize = parseFloat(tempStyle['fontSize'].replace(/[A-Za-z]/g, ''));
        for (let key in tempStyle) {
            // Not we need to check each value only, for em, pt, px etc..
            if ((/** @type {?} */ (tempStyle[key])).indexOf('em') > 0) {
                /** @type {?} */
                let suffix = tempStyle[key].replace(/[\d\.]/g, '');
                switch (suffix) {
                    case 'em': {
                        /** @type {?} */
                        let value = parseFloat(tempStyle[key].replace(/[A-Za-z]/g, ''));
                        tempStyle[key] = `${Math.round(value * fontSize)}px`;
                    }
                }
            }
        }
        return tempStyle;
    }
    /**
     * @return {?}
     */
    parseLineHeight() {
        /** @type {?} */
        let lineHeight = this.textDivRef.nativeElement.style.lineHeight;
        return parseInt(lineHeight.replace(/\D/g, ''));
    }
    /**
     * @return {?}
     */
    compareDivs() {
        /** @type {?} */
        let lineHeight = this.parseLineHeight();
        /** @type {?} */
        let dummyLines = Math.floor(this.dummyDivRef.nativeElement.clientHeight / lineHeight);
        /** @type {?} */
        let contentLines = Math.floor(this.textDivRef.nativeElement.clientHeight / lineHeight);
        /** @type {?} */
        let dummyTextWordCount = this.dummyText.split(' ').length;
        return {
            'lines': dummyLines,
            'diffLines': dummyLines - contentLines,
            'words': dummyTextWordCount
        };
    }
    /**
     * @return {?}
     */
    manageState() {
        // Protect against infinite loop.
        if (this.count-- <= 0) {
            this.trimming = false;
            this.adding = false;
            this.finishing = false;
            console.log('ERROR - loop count > 100');
        }
        if (this.trimming) {
            this.trim();
        }
        else if (this.adding) {
            this.addword();
        }
        else if (this.finishing) {
            this.finish();
        }
    }
    /**
     * @return {?}
     */
    trim() {
        /** @type {?} */
        let comps = this.compareDivs();
        /** @type {?} */
        let wordsToRemove = Math.floor(comps.words / comps.lines) * (comps.diffLines + 1);
        if (wordsToRemove > 0) {
            this.dummyText = this.dummyText.split(' ').slice(0, comps.words - wordsToRemove).join(' ');
        }
        else {
            this.trimming = false;
            this.adding = true;
            this.addword();
        }
    }
    /**
     * @return {?}
     */
    addword() {
        /** @type {?} */
        let comps = this.compareDivs();
        if (comps.diffLines <= -1) {
            if (this.dummyText.length < this.text.length) {
                this.dummyText = this.dummyText + ' ' + this.text.split(' ')[comps.words];
            }
            else {
                // This is the last node.
                this.renderer.setStyle(this.textDivRef.nativeElement, 'textAlignLast', 'left');
                NodeComponent.finishedSubject.next();
            }
        }
        else {
            // Take off the last word again.
            this.dummyText = this.dummyText.split(' ').slice(0, comps.words - 1).join(' ');
            this.adding = false;
            this.finishing = true;
        }
    }
    /**
     * @return {?}
     */
    finish() {
        /** @type {?} */
        let comps = this.compareDivs();
        /** @type {?} */
        let lastword = this.dummyText.split(' ');
        /** @type {?} */
        let overflowArray = this.text.split(' ');
        /** @type {?} */
        let overflow = overflowArray.slice(this.dummyText.split(' ').length).join(' ');
        this.text = this.dummyText;
        this.finishing = false;
        this.overflowSubject.next(overflow);
    }
}
NodeComponent.finishedSubject = new Subject();
NodeComponent.finished = /** @type {?} */ (NodeComponent.finishedSubject);
NodeComponent.headingChangedSubject = new Subject();
NodeComponent.headingChanged = NodeComponent.headingChangedSubject.pipe(debounce(() => interval(10)));
NodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-node',
                template: `
    <div class="mask" #maskTag [ngStyle]="hostStyle">
      <div *ngIf="showPageNumber && pageNumberAtTop" [ngStyle]="numberStyle">
        {{pageNumber}}
      </div>  
      <div *ngIf="showHeading" [ngStyle]="headingStyle">
        {{heading}}
      </div>
      <div #textref [ngStyle]="nodeStyle" class="content">
        {{text}}
        <div #dummy class="dummy" >{{ dummyText }}</div>
      </div>
      <div *ngIf="showPageNumber && !pageNumberAtTop" [ngStyle]="numberStyle">
        {{pageNumber}}
      </div>
    </div>
`,
                styles: [`
    .content {
      position: relative;
      text-align-last: justify;
      cursor: default;
    }
    .mask {
      display block;
      overflow: hidden;
    }
    :host {
      display: block;
      overflow: hidden;
      user-select: none;
    }
    .dummy {
      position: absolute;
      background-color: rgba(155, 255, 155, 0.4);
      left: 0px;
      top: 0px;
      visibility: hidden;
    }
  `]
            }] }
];
/** @nocollapse */
NodeComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
NodeComponent.propDecorators = {
    textDivRef: [{ type: ViewChild, args: ['textref',] }],
    dummyDivRef: [{ type: ViewChild, args: ['dummy',] }],
    mask: [{ type: ViewChild, args: ['maskTag',] }],
    hostPosition: [{ type: HostBinding, args: ['style.position',] }],
    hostVisibility: [{ type: HostBinding, args: ['style.visibility',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CreateFlowService {
    /**
     * @param {?} injector
     * @param {?} resolver
     */
    constructor(injector, resolver) {
        this.injector = injector;
        this.resolver = resolver;
        this.nodeList = new Array();
        this.firstOnTop = true;
        this.overFlowSubscriptions = [];
        this.nodesSubject = new BehaviorSubject(null);
        this.nodes = /** @type {?} */ (this.nodesSubject);
        this.nodeFactory = this.resolver.resolveComponentFactory(NodeComponent);
        // When all nodes are finished generating, do some housework.
        this.finishedSubscription = NodeComponent.finished.subscribe(() => {
            this.nodeList.forEach(node => node.isVisible = true); // Make all visible once complete.
            // If headings are modified externally, then update sibling nodes to maintain consistent formating.
            this.headingChangedSubscription = NodeComponent.headingChanged.subscribe(() => {
                /** @type {?} */
                let count = 0;
                this.nodeList.forEach(node => {
                    count = node.heading <= ' ' ? count + 1 : count - 1;
                });
                // Loop again to update the visibility of the headings.
                this.nodeList.forEach(node => {
                    node.showHeading = count === this.nodeList.length ? false : true;
                });
            });
            // Make list of nodes available once all are complete.
            this.nodesSubject.next(this.nodeList);
        });
    }
    /**
     * @return {?}
     */
    clearNodes() {
        this.nodeList = [];
    }
    /**
     * @param {?} textPassage
     * @param {?} location
     * @param {?} style
     * @param {?} showPageNumbers
     * @param {?} isOverlaid
     * @return {?}
     */
    createFlow(textPassage, location, style, showPageNumbers, isOverlaid) {
        /** @type {?} */
        let node = this.createNode(textPassage, location, style, showPageNumbers, isOverlaid);
        // Create a new node if there is any overflow text from last node generated.
        // Last node will know when it is the last one, and will
        this.overFlowSubscriptions.push(node.overflow.subscribe(overflowText => {
            if (overflowText) {
                this.createFlow(overflowText, location, style, showPageNumbers, isOverlaid);
            }
        }));
    }
    /**
     * @param {?} content
     * @param {?=} location
     * @param {?=} style
     * @param {?=} showPageNumbers
     * @param {?=} isOverlaid
     * @return {?}
     */
    createNode(content, location, style, showPageNumbers, isOverlaid) {
        /** @type {?} */
        let nodeRef;
        if (location || location instanceof ViewContainerRef) {
            nodeRef = location.createComponent(this.nodeFactory, undefined, this.injector);
        }
        else {
            nodeRef = this.nodeFactory.create(this.injector);
        }
        // Update the node
        nodeRef.instance.isOverlaid = isOverlaid;
        nodeRef.instance.showPageNumber = showPageNumbers;
        nodeRef.instance.text = content;
        if (style) {
            nodeRef.instance.applyStyle(style);
        }
        // Add node to list of nodes and update its index value.
        this.nodeList.push(nodeRef.instance);
        nodeRef.instance.index = this.firstOnTop ? 100 - this.nodeList.length : this.nodeList.length;
        return nodeRef.instance;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.finishedSubscription.unsubscribe();
        this.headingChangedSubscription.unsubscribe();
        this.overFlowSubscriptions.forEach(subscription => {
            subscription.unsubscribe();
        });
    }
}
CreateFlowService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CreateFlowService.ctorParameters = () => [
    { type: Injector },
    { type: ComponentFactoryResolver }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// A basic component that uses the CreateFlowService to generate and display the nodes
// based on the content provided in these inputs.
class NgTextflowComponent {
    /**
     * @param {?} nodeService
     */
    constructor(nodeService) {
        this.nodeService = nodeService;
        this.nodeStyles = {};
        this.firstOnTop = true;
        nodeService.firstOnTop = this.firstOnTop;
    }
    /**
     * @return {?}
     */
    get content() { return this._content; }
    /**
     * @param {?} text
     * @return {?}
     */
    set content(text) {
        this._content = text;
        // Clear the nodes out of the NodeComponent[] array.
        this.nodeService.clearNodes();
        this.viewContainer.clear();
        this.nodeService.createFlow(this.content, this.viewContainer, this.nodeStyles, this.showPageNumbers, this.isOverlaid);
    }
}
NgTextflowComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-textflow',
                template: ` 
    <ng-container #viewContainer></ng-container>
  `
            }] }
];
/** @nocollapse */
NgTextflowComponent.ctorParameters = () => [
    { type: CreateFlowService }
];
NgTextflowComponent.propDecorators = {
    viewContainer: [{ type: ViewChild, args: ['viewContainer', { read: ViewContainerRef },] }],
    nodeStyles: [{ type: Input }],
    firstOnTop: [{ type: Input }],
    showPageNumbers: [{ type: Input }],
    isOverlaid: [{ type: Input }],
    content: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgTextflowModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgTextflowModule,
            providers: [CreateFlowService]
        };
    }
}
NgTextflowModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NgTextflowComponent, NodeComponent],
                entryComponents: [NodeComponent],
                exports: [NgTextflowComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgTextflowModule, NodeComponent, CreateFlowService, NgTextflowComponent as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctdGV4dGZsb3cuanMubWFwIiwic291cmNlcyI6WyJuZzovL25nLXRleHRmbG93L25nLXRleHRmbG93L25vZGUuY29tcG9uZW50LnRzIiwibmc6Ly9uZy10ZXh0Zmxvdy9uZy10ZXh0Zmxvdy9jcmVhdGUtZmxvdy5zZXJ2aWNlLnRzIiwibmc6Ly9uZy10ZXh0Zmxvdy9uZy10ZXh0Zmxvdy9uZy10ZXh0Zmxvdy5jb21wb25lbnQudHMiLCJuZzovL25nLXRleHRmbG93L25nLXRleHRmbG93L25nLXRleHRmbG93Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgRWxlbWVudFJlZiwgVmlld0NoaWxkLCBSZW5kZXJlcjIsIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgaW50ZXJ2YWwgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vLyBAZHluYW1pY1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2FwcC1ub2RlJyxcclxuICB0ZW1wbGF0ZTogYFxyXG4gICAgPGRpdiBjbGFzcz1cIm1hc2tcIiAjbWFza1RhZyBbbmdTdHlsZV09XCJob3N0U3R5bGVcIj5cclxuICAgICAgPGRpdiAqbmdJZj1cInNob3dQYWdlTnVtYmVyICYmIHBhZ2VOdW1iZXJBdFRvcFwiIFtuZ1N0eWxlXT1cIm51bWJlclN0eWxlXCI+XHJcbiAgICAgICAge3twYWdlTnVtYmVyfX1cclxuICAgICAgPC9kaXY+ICBcclxuICAgICAgPGRpdiAqbmdJZj1cInNob3dIZWFkaW5nXCIgW25nU3R5bGVdPVwiaGVhZGluZ1N0eWxlXCI+XHJcbiAgICAgICAge3toZWFkaW5nfX1cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgI3RleHRyZWYgW25nU3R5bGVdPVwibm9kZVN0eWxlXCIgY2xhc3M9XCJjb250ZW50XCI+XHJcbiAgICAgICAge3t0ZXh0fX1cclxuICAgICAgICA8ZGl2ICNkdW1teSBjbGFzcz1cImR1bW15XCIgPnt7IGR1bW15VGV4dCB9fTwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiAqbmdJZj1cInNob3dQYWdlTnVtYmVyICYmICFwYWdlTnVtYmVyQXRUb3BcIiBbbmdTdHlsZV09XCJudW1iZXJTdHlsZVwiPlxyXG4gICAgICAgIHt7cGFnZU51bWJlcn19XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbmAsXHJcbiAgc3R5bGVzOiBbYFxyXG4gICAgLmNvbnRlbnQge1xyXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICAgIHRleHQtYWxpZ24tbGFzdDoganVzdGlmeTtcclxuICAgICAgY3Vyc29yOiBkZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgLm1hc2sge1xyXG4gICAgICBkaXNwbGF5IGJsb2NrO1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgfVxyXG4gICAgOmhvc3Qge1xyXG4gICAgICBkaXNwbGF5OiBibG9jaztcclxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICB9XHJcbiAgICAuZHVtbXkge1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTU1LCAyNTUsIDE1NSwgMC40KTtcclxuICAgICAgbGVmdDogMHB4O1xyXG4gICAgICB0b3A6IDBweDtcclxuICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xyXG4gICAgfVxyXG4gIGBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOb2RlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICBAVmlld0NoaWxkKCd0ZXh0cmVmJykgcHJpdmF0ZSB0ZXh0RGl2UmVmOiBFbGVtZW50UmVmO1xyXG4gIEBWaWV3Q2hpbGQoJ2R1bW15JykgIHByaXZhdGUgZHVtbXlEaXZSZWY6IEVsZW1lbnRSZWY7XHJcbiAgQFZpZXdDaGlsZCgnbWFza1RhZycpIHByaXZhdGUgbWFzazogRWxlbWVudFJlZjtcclxuXHJcbiAgcHJpdmF0ZSBfaW5kZXg6IG51bWJlcjsgIFxyXG4gIHByaXZhdGUgX2hlYWRpbmc6IHN0cmluZyA9ICcnO1xyXG4gIHByaXZhdGUgX2lzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX3BhZ2VOdW1iZXJBdFRvcDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgY2hhbmdlczogTXV0YXRpb25PYnNlcnZlcjtcclxuICBwcml2YXRlIHBhZGRpbmc6IG51bWJlcjtcclxuICBcclxuICBzaG93SGVhZGluZzogYm9vbGVhbiA9IHRydWU7XHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIHNob3dQYWdlTnVtYmVyOiBib29sZWFuO1xyXG4gIGlzT3ZlcmxhaWQ6IGJvb2xlYW47XHJcbiAgcGFnZU51bWJlcjogbnVtYmVyO1xyXG5cclxuICAvLyBHZXQgaG9zdCBwcm9wZXJ0aWVzIHRvIGR5bmFtaWNhbGx5IGNoYW5nZS5cclxuICBASG9zdEJpbmRpbmcoJ3N0eWxlLnBvc2l0aW9uJykgaG9zdFBvc2l0aW9uID0gJyc7XHJcbiAgQEhvc3RCaW5kaW5nKCdzdHlsZS52aXNpYmlsaXR5JykgaG9zdFZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHJcbiAgLy8gRHluYW1pYyBzdHlsZXMuXHJcbiAgbnVtYmVyU3R5bGU6IGFueSA9IHt9O1xyXG4gIGhlYWRpbmdTdHlsZTogYW55ID0ge307XHJcbiAgbm9kZVN0eWxlOiBhbnkgPSB7fTtcclxuICBob3N0U3R5bGU6IGFueSA9IHt9O1xyXG5cclxuICAvLyBEZWZhdWx0IHN0eWxlIGluY2FzZSB0aGVyZSBpcyBub25lIHN1cHBsaWVkLlxyXG4gIHByaXZhdGUgZGVmYXVsdFN0eWxlcyA9IHtcclxuICAgIGhvc3RTdHlsZToge30sXHJcbiAgICBjb250ZW50U3R5bGU6IHtcclxuICAgICAgJ2hlaWdodCc6ICc5ZW0nLFxyXG4gICAgICAnd2lkdGgnOiAnMjAwcHgnLFxyXG4gICAgICAnZm9udFNpemUnOiAnMTFweCcsXHJcbiAgICAgICd3b3JkU3BhY2luZyc6ICcycHgnLFxyXG4gICAgICAndGV4dEFsaWduJzogJ2p1c3RpZnknLFxyXG4gICAgICAnbGluZUhlaWdodCc6ICcxLjFlbScsXHJcbiAgICAgICdsZWZ0QWxpZ25MYXN0JzogJ2p1c3RpZmllZCdcclxuICAgIH0sXHJcbiAgICBoZWFkaW5nU3R5bGU6IHtcclxuICAgICAgJ2ZvbnQtc2l6ZSc6ICcxNHB4JyxcclxuICAgICAgJ2hlaWdodCc6ICcyNXB4J1xyXG4gICAgfSxcclxuICAgIG51bWJlclN0eWxlOiB7XHJcbiAgICAgICdmb250LXNpemUnOiAnMTBweCcsXHJcbiAgICB9XHJcbiAgfTsgXHJcblxyXG4gIC8vIE1vcmUgdGV4dCB0byBwdXQgaW50byBub2Rlcywgc28gb3ZlcmZsb3cuXHJcbiAgcHJpdmF0ZSBvdmVyZmxvd1N1YmplY3Q6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgb3ZlcmZsb3c6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMub3ZlcmZsb3dTdWJqZWN0IGFzIE9ic2VydmFibGU8c3RyaW5nPjtcclxuXHJcbiAgLy8gTGFzdCBub2RlIGNvbXBsZXRlLlxyXG4gIHByaXZhdGUgc3RhdGljIGZpbmlzaGVkU3ViamVjdDogU3ViamVjdDxudWxsPiA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgc3RhdGljIGZpbmlzaGVkOiBPYnNlcnZhYmxlPG51bGw+ID0gTm9kZUNvbXBvbmVudC5maW5pc2hlZFN1YmplY3QgYXMgT2JzZXJ2YWJsZTxudWxsPjtcclxuXHJcbiAgLy8gSGVhZGluZyBoYXMgY2hhbmdlZC5cclxuICBwcml2YXRlIHN0YXRpYyBoZWFkaW5nQ2hhbmdlZFN1YmplY3Q6IFN1YmplY3Q8bnVsbD4gPSBuZXcgU3ViamVjdCgpO1xyXG4gIHN0YXRpYyBoZWFkaW5nQ2hhbmdlZDogT2JzZXJ2YWJsZTxudWxsPiA9IE5vZGVDb21wb25lbnQuaGVhZGluZ0NoYW5nZWRTdWJqZWN0LnBpcGUoZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTApKSk7XHJcblxyXG4gIC8vIEluamVjdCBzZXJ2aWNlcy5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9O1xyXG5cclxuICBuZ09uSW5pdCgpIHsgICAgXHJcbiAgICAvLyBTb21lIGluaXRpYWxpc2F0aW9uLlxyXG4gICAgdGhpcy5kdW1teVRleHQgPSB0aGlzLnRleHQ7XHJcbiAgICB0aGlzLnRyaW1taW5nID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBXZSB1c2UgdGhlIG11dGF0aW9uIG9ic2VydmVyIHRvIHNlZSB3aGVuIG91ciBkdW1teSB0ZXh0IGNoYW5nZSBoYXMgaGFwcGVuZWQuXHJcbiAgICB0aGlzLmNoYW5nZXMgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKSA9PiB0aGlzLm1hbmFnZVN0YXRlKCkpO1xyXG4gICAgdGhpcy5jaGFuZ2VzLm9ic2VydmUodGhpcy5kdW1teURpdlJlZi5uYXRpdmVFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcclxuXHJcbiAgICAvLyBLaWNrIG9mZiB0aGUgc3RhdGUgbWFjaGluZSBoZXJlLCBidXQgd2l0aCBhIGRlbGF5IGZvciB0aGUgZmlyc3Qgbm9kZSxcclxuICAgIC8vIHNpbmNlIHRoZSBpbml0aWFsIGxvYWRpbmcgb2YgdGhlIGNvbXBvbmVudCBjYXVzZXMgc29tZSBkZWxheSBpbiBvdGhlciBpbml0aWFsaXNhdGlvbi4gKEkgdGhpbmspLlxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIFdhaXQgdGlsbCBpbmRleCBpcyByZXNvbHZlZC5cclxuICAgICAgLy8gV2UgbmVlZCB0byBwYXVzZSBmb3IgdGhlIGZpcnN0IG5vZGUgc2luY2UgdGhlIGxvYWRpbmcgaXMgbGF6eT9cclxuICAgICAgaWYgKHRoaXMuaW5kZXggPj0gOTkpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubWFuYWdlU3RhdGUoKSwgMjAwKTsgLy8gVE9ETzogZmluZCBhIGV2ZW50IGRyaXZlbiBtZXRob2QgaGVyZS5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIG5vZGVzIGRvIG5vdCBuZWVkIHRoaXMgZGVsYXkuXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VTdGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gU29tZSBnZXR0ZXIvc2V0dGVyIG1ldGhvZHMuXHJcbiAgZ2V0IGR1bW15VGV4dCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5kdW1teURpdlJlZi5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50OyB9XHJcbiAgc2V0IGR1bW15VGV4dChjb250ZW50OiBzdHJpbmcpIHsgdGhpcy5kdW1teURpdlJlZi5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDsgfVxyXG4gIFxyXG4gIGdldCBpc1Zpc2libGUoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9pc1Zpc2libGU7IH1cclxuICBzZXQgaXNWaXNpYmxlKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9pc1Zpc2libGUgPSB2YWx1ZTtcclxuICAgIHRoaXMuaG9zdFZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgfVxyXG5cclxuICBnZXQgaW5kZXgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2luZGV4OyB9XHJcbiAgc2V0IGluZGV4KGluZGV4OiBudW1iZXIpIHtcclxuICAgIHRoaXMucGFnZU51bWJlciA9IDEwMCAtIGluZGV4O1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2luZGV4ID0gTWF0aC5hYnMoaW5kZXgpO1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnei1pbmRleCcsIGluZGV4KTsgXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGdldCB3aWR0aCgpOiBudW1iZXIgeyByZXR1cm4gcGFyc2VJbnQodGhpcy5tYXNrLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGgucmVwbGFjZSgvXFxEL2csICcnKSkgfVxyXG4gIHNldCB3aWR0aCh3aWR0aDogbnVtYmVyKSB7IHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5tYXNrLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIGAke3dpZHRofXB4YCkgfVxyXG4gIFxyXG4gIGdldCBoZWFkaW5nKCk6IHN0cmluZyB7IHJldHVybiB0aGlzLl9oZWFkaW5nOyB9XHJcbiAgc2V0IGhlYWRpbmcoaGVhZGluZzogc3RyaW5nKSB7IFxyXG4gICAgdGhpcy5faGVhZGluZyA9IGhlYWRpbmcgPT09ICcnID8gdGhpcy5faGVhZGluZyA9ICcgJyA6IHRoaXMuX2hlYWRpbmcgPSBoZWFkaW5nO1xyXG4gICAgTm9kZUNvbXBvbmVudC5oZWFkaW5nQ2hhbmdlZFN1YmplY3QubmV4dCgpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBhZ2VOdW1iZXJBdFRvcCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3BhZ2VOdW1iZXJBdFRvcDsgfVxyXG4gIHNldCBwYWdlTnVtYmVyQXRUb3AodmFsdWU6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMuX3BhZ2VOdW1iZXJBdFRvcCA9IHZhbHVlO1xyXG4gICAgdGhpcy5udW1iZXJTdHlsZVsncGFkZGluZy1ib3R0b20nXSA9IHRoaXMucGFnZU51bWJlckF0VG9wID8gJzBweCcgOiBgJHt0aGlzLnBhZGRpbmd9cHhgO1xyXG4gICAgdGhpcy5udW1iZXJTdHlsZVsncGFkZGluZy10b3AnXSA9IHRoaXMucGFnZU51bWJlckF0VG9wID8gYCR7dGhpcy5wYWRkaW5nfXB4YCA6ICcwcHgnO1xyXG4gIH1cclxuXHJcbiAgLy8gQXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBjdXJyZW50IG5vZGUuIEFzc3VtZXMgdGhlIGNvcnJlY3QgYXR0cmlidXRlcyBhcmUgY29udGFpbmVkLlxyXG4gIGFwcGx5U3R5bGUoc3R5bGU6IGFueSkge1xyXG4gICAgdGhpcy5ub2RlU3R5bGUgPSBzdHlsZS5jb250ZW50U3R5bGUgPyB0aGlzLmNvbnZlcnRTdHlsZVRvUHgoc3R5bGUuY29udGVudFN0eWxlKSA6IHRoaXMuY29udmVydFN0eWxlVG9QeCh0aGlzLmRlZmF1bHRTdHlsZXMuY29udGVudFN0eWxlKTtcclxuICAgIHRoaXMubnVtYmVyU3R5bGUgPSBzdHlsZS5udW1iZXJTdHlsZSA/IHN0eWxlLm51bWJlclN0eWxlIDogdGhpcy5kZWZhdWx0U3R5bGVzLm51bWJlclN0eWxlO1xyXG4gICAgdGhpcy5ob3N0U3R5bGUgPSBzdHlsZS5ob3N0U3R5bGUgPyBzdHlsZS5ob3N0U3R5bGUgOiB0aGlzLmRlZmF1bHRTdHlsZXMuaG9zdFN0eWxlO1xyXG4gICAgLy8gTGV0J3MgbWFuaXB1bGF0ZSB0aGUgcGFkZGluZyBzdHlsZSB0aGF0IHdhcyBhZGRlZCB0byBtYW5hZ2UgdG9wIG9yIGJvdHRvbSBwbGFjZWQgbnVtYmVyaW5nLlxyXG4gICAgaWYgKHRoaXMubnVtYmVyU3R5bGUucGFkZGluZyA+ICcnKSB7XHJcbiAgICAgIHRoaXMucGFkZGluZyA9IHBhcnNlSW50KHRoaXMubnVtYmVyU3R5bGUucGFkZGluZy5yZXBsYWNlKC9cXEQvZywgJycpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGFkZGluZyA9IDE2O1xyXG4gICAgfVxyXG4gICAgdGhpcy5udW1iZXJTdHlsZVsncGFkZGluZy1sZWZ0J10gPSBgJHtwYXJzZUludCh0aGlzLm5vZGVTdHlsZS53aWR0aC5yZXBsYWNlKC9cXEQvZywgJycpKS8yfXB4YDtcclxuICAgIHRoaXMuaGVhZGluZ1N0eWxlID0gc3R5bGUuaGVhZGluZ1N0eWxlID8gc3R5bGUuaGVhZGluZ1N0eWxlIDogdGhpcy5kZWZhdWx0U3R5bGVzLmhlYWRpbmdTdHlsZTtcclxuICAgIHRoaXMuaGVhZGluZ1N0eWxlLndpZHRoID0gdGhpcy5ub2RlU3R5bGUud2lkdGg7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBzdHlsZS53aWR0aCk7XHJcbiAgICB0aGlzLm5vZGVTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgdGhpcy53aWR0aCA9IHBhcnNlSW50KHRoaXMubm9kZVN0eWxlLndpZHRoLnJlcGxhY2UoL1xcRC9nLCAnJykpO1xyXG4gICAgaWYgKHRoaXMuaXNPdmVybGFpZCkge1xyXG4gICAgICB0aGlzLmhvc3RQb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGVtIHZhbHVlcyBpbnRvIHB4IHZhbHVlcyBmb3Igc2ltcGxlciBjYWxjdWxhdGlvbiBsYXRlci5cclxuICBwcml2YXRlIGNvbnZlcnRTdHlsZVRvUHgoc3R5bGU6IGFueSk6IGFueSB7XHJcbiAgICBsZXQgdGVtcFN0eWxlID0gc3R5bGU7XHJcbiAgICAvLyBHZXQgdGhlIGZvbnRTaXplIG9mIHRoZSBzdHlsZS5cclxuICAgIGxldCBmb250U2l6ZVN1ZmZpeDogc3RyaW5nID0gdGVtcFN0eWxlWydmb250U2l6ZSddLnJlcGxhY2UoL1tcXGRcXC5dL2csICcnKTtcclxuICAgIGxldCBmb250U2l6ZTogbnVtYmVyID0gcGFyc2VGbG9hdCh0ZW1wU3R5bGVbJ2ZvbnRTaXplJ10ucmVwbGFjZSgvW0EtWmEtel0vZywnJykpO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBrZXkgaW4gdGVtcFN0eWxlKSB7XHJcbiAgICAgIC8vIE5vdCB3ZSBuZWVkIHRvIGNoZWNrIGVhY2ggdmFsdWUgb25seSwgZm9yIGVtLCBwdCwgcHggZXRjLi5cclxuICAgICAgaWYgKCg8c3RyaW5nPnRlbXBTdHlsZVtrZXldKS5pbmRleE9mKCdlbScpID4gMCkge1xyXG4gICAgICAgIGxldCBzdWZmaXggPSB0ZW1wU3R5bGVba2V5XS5yZXBsYWNlKC9bXFxkXFwuXS9nLCAnJyk7XHJcbiAgICAgICAgc3dpdGNoKHN1ZmZpeCkge1xyXG4gICAgICAgICAgY2FzZSAnZW0nOiB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgZW0gdmFsdWUgdG8gcHhcclxuICAgICAgICAgICAgbGV0IHZhbHVlOiBudW1iZXIgPSBwYXJzZUZsb2F0KHRlbXBTdHlsZVtrZXldLnJlcGxhY2UoL1tBLVphLXpdL2csJycpKTtcclxuICAgICAgICAgICAgdGVtcFN0eWxlW2tleV0gPSBgJHtNYXRoLnJvdW5kKHZhbHVlKmZvbnRTaXplKX1weGBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZW1wU3R5bGU7XHJcbiAgfVxyXG5cclxuICAvLyBHZXRzIHRoZSBsaW5lSGVpZ2h0IG9mIHRoZSBjdXJyZW50IG5vZGUgc28gd2UgY2FuIGRvIG90aGVyIHRyaW1taW5nIGNhbGN1bGF0aW9ucy5cclxuICBwcml2YXRlIHBhcnNlTGluZUhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgbGV0IGxpbmVIZWlnaHQ6IHN0cmluZyA9IHRoaXMudGV4dERpdlJlZi5uYXRpdmVFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQ7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQobGluZUhlaWdodC5yZXBsYWNlKC9cXEQvZywgJycpKTtcclxuICB9XHJcbiAgXHJcbiAgLy8gUHJvZHVjZXMgYSBzZXQgb2YgZGF0YSBhYm91dCB0aGUgY3VycmVudCBkdW1teSBkaXYgY29tcGF0ZWQgdG8gdGhlIGNvbnRlbnQgZGl2LlxyXG4gIHByaXZhdGUgY29tcGFyZURpdnMoKTogeyAnbGluZXMnOiBudW1iZXIsICdkaWZmTGluZXMnOiBudW1iZXIsICd3b3Jkcyc6IG51bWJlciB9IHtcclxuICAgIGxldCBsaW5lSGVpZ2h0ID0gdGhpcy5wYXJzZUxpbmVIZWlnaHQoKTtcclxuICAgIGxldCBkdW1teUxpbmVzID0gTWF0aC5mbG9vcih0aGlzLmR1bW15RGl2UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gbGluZUhlaWdodCk7XHJcbiAgICBsZXQgY29udGVudExpbmVzID0gTWF0aC5mbG9vcih0aGlzLnRleHREaXZSZWYubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQgLyBsaW5lSGVpZ2h0KTtcclxuICAgIGxldCBkdW1teVRleHRXb3JkQ291bnQgPSB0aGlzLmR1bW15VGV4dC5zcGxpdCgnICcpLmxlbmd0aDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnbGluZXMnOiBkdW1teUxpbmVzLFxyXG4gICAgICAnZGlmZkxpbmVzJzogZHVtbXlMaW5lcyAtIGNvbnRlbnRMaW5lcyxcclxuICAgICAgJ3dvcmRzJzogZHVtbXlUZXh0V29yZENvdW50XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFRyaW0gbG9vcCB0ZXN0LiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIC8vXHJcbiAgLy8gVGhpcyBpcyBhIHNtYWxsIHN0YXRlIG1hY2hpbmUgdG8gcHJvY2VzcyB0aGUgdHJpbW1pbmcgYWxnb3JpdGhtLlxyXG4gIC8vXHJcbiAgcHJpdmF0ZSBhZGRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBwcml2YXRlIGZpbmlzaGluZzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gIHByaXZhdGUgdHJpbW1pbmc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICBcclxuICBwcml2YXRlIGNvdW50OiBudW1iZXIgPSAxMDA7XHJcblxyXG4gIHByaXZhdGUgbWFuYWdlU3RhdGUoKSB7XHJcbiAgICAvLyBQcm90ZWN0IGFnYWluc3QgaW5maW5pdGUgbG9vcC5cclxuICAgIGlmICh0aGlzLmNvdW50LS0gPD0gMCApIHtcclxuICAgICAgdGhpcy50cmltbWluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmFkZGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmZpbmlzaGluZyA9IGZhbHNlO1xyXG4gICAgICBjb25zb2xlLmxvZygnRVJST1IgLSBsb29wIGNvdW50ID4gMTAwJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy50cmltbWluZykge1xyXG4gICAgICB0aGlzLnRyaW0oKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5hZGRpbmcpIHtcclxuICAgICAgdGhpcy5hZGR3b3JkKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmluaXNoaW5nKSB7XHJcbiAgICAgIHRoaXMuZmluaXNoKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHRyaW0oKSB7XHJcbiAgICBsZXQgY29tcHMgPSB0aGlzLmNvbXBhcmVEaXZzKCk7XHJcbiAgICBsZXQgd29yZHNUb1JlbW92ZSA9IE1hdGguZmxvb3IoY29tcHMud29yZHMvY29tcHMubGluZXMpICogKGNvbXBzLmRpZmZMaW5lcyArIDEpO1xyXG4gICAgaWYgKHdvcmRzVG9SZW1vdmUgPiAwKSB7XHJcbiAgICAgIHRoaXMuZHVtbXlUZXh0ID0gdGhpcy5kdW1teVRleHQuc3BsaXQoJyAnKS5zbGljZSgwLCBjb21wcy53b3JkcyAtIHdvcmRzVG9SZW1vdmUpLmpvaW4oJyAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMudHJpbW1pbmcgPSBmYWxzZTtcclxuICAgICAgdGhpcy5hZGRpbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLmFkZHdvcmQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYWRkd29yZCgpIHtcclxuICAgIGxldCBjb21wcyA9IHRoaXMuY29tcGFyZURpdnMoKTtcclxuICAgIGlmIChjb21wcy5kaWZmTGluZXMgPD0gLTEpIHtcclxuICAgICAgaWYgKHRoaXMuZHVtbXlUZXh0Lmxlbmd0aCA8IHRoaXMudGV4dC5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmR1bW15VGV4dCA9IHRoaXMuZHVtbXlUZXh0ICsgJyAnICsgdGhpcy50ZXh0LnNwbGl0KCcgJylbY29tcHMud29yZHNdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgbm9kZS5cclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudGV4dERpdlJlZi5uYXRpdmVFbGVtZW50LCAndGV4dEFsaWduTGFzdCcsICdsZWZ0Jyk7XHJcbiAgICAgICAgTm9kZUNvbXBvbmVudC5maW5pc2hlZFN1YmplY3QubmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBUYWtlIG9mZiB0aGUgbGFzdCB3b3JkIGFnYWluLlxyXG4gICAgICB0aGlzLmR1bW15VGV4dCA9IHRoaXMuZHVtbXlUZXh0LnNwbGl0KCcgJykuc2xpY2UoMCwgY29tcHMud29yZHMgLSAxKS5qb2luKCcgJyk7XHJcbiAgICAgIHRoaXMuYWRkaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuZmluaXNoaW5nID0gdHJ1ZTsgICAgICAgIFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBmaW5pc2goKSB7XHJcbiAgICBsZXQgY29tcHMgPSB0aGlzLmNvbXBhcmVEaXZzKCk7XHJcbiAgICBsZXQgbGFzdHdvcmQ6IHN0cmluZ1tdID0gdGhpcy5kdW1teVRleHQuc3BsaXQoJyAnKTtcclxuICAgIGxldCBvdmVyZmxvd0FycmF5ID0gdGhpcy50ZXh0LnNwbGl0KCcgJyk7XHJcbiAgICBsZXQgb3ZlcmZsb3cgPSBvdmVyZmxvd0FycmF5LnNsaWNlKHRoaXMuZHVtbXlUZXh0LnNwbGl0KCcgJykubGVuZ3RoKS5qb2luKCcgJyk7XHJcbiAgICB0aGlzLnRleHQgPSB0aGlzLmR1bW15VGV4dDtcclxuICAgIHRoaXMuZmluaXNoaW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLm92ZXJmbG93U3ViamVjdC5uZXh0KG92ZXJmbG93KTtcclxuICB9XHJcblxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXHJcbiAgICAgICAgIENvbXBvbmVudEZhY3RvcnksIFZpZXdDb250YWluZXJSZWYsIENvbXBvbmVudFJlZiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5vZGVDb21wb25lbnQgfSBmcm9tICcuL25vZGUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIENyZWF0ZUZsb3dTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcclxuICBwcml2YXRlIG5vZGVMaXN0OiBOb2RlQ29tcG9uZW50W10gPSBuZXcgQXJyYXk8Tm9kZUNvbXBvbmVudD4oKTtcclxuICBwcml2YXRlIG5vZGVGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PE5vZGVDb21wb25lbnQ+O1xyXG4gIGZpcnN0T25Ub3A6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAvLyBTdWJzY3JpcHRpb25zXHJcbiAgcHJpdmF0ZSBmaW5pc2hlZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uOyAvLyBGb3Igd2hlbiB0aGUgbm9kZXMgYXJlIGNvbXBsZXRlLlxyXG4gIHByaXZhdGUgaGVhZGluZ0NoYW5nZWRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjsgLy8gRm9yIHdoZW4gdGhlIGhlYWRpbmcgaXMgZXh0ZXJuYWxseSBjaGFuZ2VkLlxyXG4gIHByaXZhdGUgb3ZlckZsb3dTdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdOyAvLyBEdXJpbmcgZ2VuZXJhdGlvbiBvZiBub2RlcywgZmlyZXMgd2hlbiB0aGVyZSBhcmUgbW9yZSBub2RlcyB0byBnZW5lcmF0ZS5cclxuXHJcbiAgLy8gUHJvdmlkZSBhbiBhcnJheSBvZiBub2RlcyBvbmNlIHRoZSBnZW5lcmF0aW9uIGlzIGNvbXBsZXRlLlxyXG4gIHByaXZhdGUgbm9kZXNTdWJqZWN0OiBTdWJqZWN0PE5vZGVDb21wb25lbnRbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5vZGVDb21wb25lbnRbXT4obnVsbCk7XHJcbiAgbm9kZXM6IE9ic2VydmFibGU8Tm9kZUNvbXBvbmVudFtdPiA9IHRoaXMubm9kZXNTdWJqZWN0IGFzIE9ic2VydmFibGU8Tm9kZUNvbXBvbmVudFtdPjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsIHByaXZhdGUgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikge1xyXG4gICAgdGhpcy5ub2RlRmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoTm9kZUNvbXBvbmVudCk7XHJcbiAgICBcclxuICAgIC8vIFdoZW4gYWxsIG5vZGVzIGFyZSBmaW5pc2hlZCBnZW5lcmF0aW5nLCBkbyBzb21lIGhvdXNld29yay5cclxuICAgIHRoaXMuZmluaXNoZWRTdWJzY3JpcHRpb24gPSAgTm9kZUNvbXBvbmVudC5maW5pc2hlZC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICB0aGlzLm5vZGVMaXN0LmZvckVhY2gobm9kZSA9PiAgbm9kZS5pc1Zpc2libGUgPSB0cnVlKTsgLy8gTWFrZSBhbGwgdmlzaWJsZSBvbmNlIGNvbXBsZXRlLlxyXG5cclxuICAgICAgLy8gSWYgaGVhZGluZ3MgYXJlIG1vZGlmaWVkIGV4dGVybmFsbHksIHRoZW4gdXBkYXRlIHNpYmxpbmcgbm9kZXMgdG8gbWFpbnRhaW4gY29uc2lzdGVudCBmb3JtYXRpbmcuXHJcbiAgICAgIHRoaXMuaGVhZGluZ0NoYW5nZWRTdWJzY3JpcHRpb24gPSBOb2RlQ29tcG9uZW50LmhlYWRpbmdDaGFuZ2VkLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgLy8gTG9vcCBvbmNlIHRvIHNlZSBpZiBhbGwgYXJlIGVtcHR5LlxyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ub2RlTGlzdC5mb3JFYWNoKG5vZGUgPT4geyBcclxuICAgICAgICAgIGNvdW50ID0gbm9kZS5oZWFkaW5nIDw9ICcgJyA/IGNvdW50ICsgMSA6IGNvdW50IC0gMTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gTG9vcCBhZ2FpbiB0byB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGhlYWRpbmdzLlxyXG4gICAgICAgIHRoaXMubm9kZUxpc3QuZm9yRWFjaChub2RlID0+IHtcclxuICAgICAgICAgIG5vZGUuc2hvd0hlYWRpbmcgPSBjb3VudCA9PT0gdGhpcy5ub2RlTGlzdC5sZW5ndGggPyBmYWxzZSA6IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gTWFrZSBsaXN0IG9mIG5vZGVzIGF2YWlsYWJsZSBvbmNlIGFsbCBhcmUgY29tcGxldGUuXHJcbiAgICAgIHRoaXMubm9kZXNTdWJqZWN0Lm5leHQodGhpcy5ub2RlTGlzdCk7XHJcbiAgICB9KTtcclxuICB9IFxyXG5cclxuICBjbGVhck5vZGVzKCkge1xyXG4gICAgdGhpcy5ub2RlTGlzdCA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhpcyB3aWxsIGtpY2sgb2ZmIGEgcHJvY2VzcyB0aGF0IGdlbmVyYXRlcyBhIG5vZGUgZXZlcnkgdGltZSBhIGdlbmVyYXRlZCBub2RlIGlzIHRvbyBmdWxsIGFuZCBvdmVyZmxvd3Mgd2l0aCB0ZXh0LlxyXG4gIGNyZWF0ZUZsb3codGV4dFBhc3NhZ2U6IHN0cmluZywgXHJcbiAgICAgICAgICAgICBsb2NhdGlvbjogVmlld0NvbnRhaW5lclJlZiwgXHJcbiAgICAgICAgICAgICBzdHlsZTogYW55LCBcclxuICAgICAgICAgICAgIHNob3dQYWdlTnVtYmVyczogYm9vbGVhbiwgXHJcbiAgICAgICAgICAgICBpc092ZXJsYWlkOiBib29sZWFuKSB7XHJcblxyXG4gICAgbGV0IG5vZGU6IE5vZGVDb21wb25lbnQgPSB0aGlzLmNyZWF0ZU5vZGUodGV4dFBhc3NhZ2UsIGxvY2F0aW9uLCBzdHlsZSwgc2hvd1BhZ2VOdW1iZXJzLCBpc092ZXJsYWlkKTtcclxuICAgIFxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IG5vZGUgaWYgdGhlcmUgaXMgYW55IG92ZXJmbG93IHRleHQgZnJvbSBsYXN0IG5vZGUgZ2VuZXJhdGVkLlxyXG4gICAgLy8gTGFzdCBub2RlIHdpbGwga25vdyB3aGVuIGl0IGlzIHRoZSBsYXN0IG9uZSwgYW5kIHdpbGwgXHJcbiAgICB0aGlzLm92ZXJGbG93U3Vic2NyaXB0aW9ucy5wdXNoKG5vZGUub3ZlcmZsb3cuc3Vic2NyaWJlKG92ZXJmbG93VGV4dCA9PiB7XHJcbiAgICAgIGlmIChvdmVyZmxvd1RleHQpIHtcclxuICAgICAgICB0aGlzLmNyZWF0ZUZsb3cob3ZlcmZsb3dUZXh0LCBsb2NhdGlvbiwgc3R5bGUsIHNob3dQYWdlTnVtYmVycywgaXNPdmVybGFpZCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlTm9kZShjb250ZW50OiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uPzogVmlld0NvbnRhaW5lclJlZiwgXHJcbiAgICAgICAgICAgICAgICAgICAgIHN0eWxlPzogYW55LCBzaG93UGFnZU51bWJlcnM/OiBcclxuICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbiwgaXNPdmVybGFpZD86IGJvb2xlYW4pOiBOb2RlQ29tcG9uZW50IHtcclxuICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgIC8vIEdlbmVyYXRlIHRoZSBub2RlIHdpdGggdGhlIG5vZGVGYWN0b3J5LlxyXG4gICAgbGV0IG5vZGVSZWY6IENvbXBvbmVudFJlZjxOb2RlQ29tcG9uZW50PjtcclxuICAgIGlmIChsb2NhdGlvbiB8fCBsb2NhdGlvbiBpbnN0YW5jZW9mIFZpZXdDb250YWluZXJSZWYpIHtcclxuICAgICAgbm9kZVJlZiA9IGxvY2F0aW9uLmNyZWF0ZUNvbXBvbmVudCh0aGlzLm5vZGVGYWN0b3J5LCB1bmRlZmluZWQsIHRoaXMuaW5qZWN0b3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbm9kZVJlZiA9IHRoaXMubm9kZUZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgdGhlIG5vZGVcclxuICAgIG5vZGVSZWYuaW5zdGFuY2UuaXNPdmVybGFpZCA9IGlzT3ZlcmxhaWQ7XHJcbiAgICBub2RlUmVmLmluc3RhbmNlLnNob3dQYWdlTnVtYmVyID0gc2hvd1BhZ2VOdW1iZXJzO1xyXG4gICAgbm9kZVJlZi5pbnN0YW5jZS50ZXh0ID0gY29udGVudDtcclxuICAgIGlmIChzdHlsZSkge1xyXG4gICAgICBub2RlUmVmLmluc3RhbmNlLmFwcGx5U3R5bGUoc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgbm9kZSB0byBsaXN0IG9mIG5vZGVzIGFuZCB1cGRhdGUgaXRzIGluZGV4IHZhbHVlLlxyXG4gICAgdGhpcy5ub2RlTGlzdC5wdXNoKG5vZGVSZWYuaW5zdGFuY2UpO1xyXG4gICAgbm9kZVJlZi5pbnN0YW5jZS5pbmRleCA9IHRoaXMuZmlyc3RPblRvcCA/IDEwMC10aGlzLm5vZGVMaXN0Lmxlbmd0aCA6IHRoaXMubm9kZUxpc3QubGVuZ3RoO1xyXG5cclxuICAgIHJldHVybiBub2RlUmVmLmluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgLy8gVGlkeSB1cCBzdWJzY3JpcHRpb25zLlxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5maW5pc2hlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5oZWFkaW5nQ2hhbmdlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgdGhpcy5vdmVyRmxvd1N1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4ge1xyXG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBWaWV3Q2hpbGQsIFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbiAgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDcmVhdGVGbG93U2VydmljZSB9IGZyb20gJy4vY3JlYXRlLWZsb3cuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ25nLXRleHRmbG93JyxcclxuICB0ZW1wbGF0ZTogYCBcclxuICAgIDxuZy1jb250YWluZXIgI3ZpZXdDb250YWluZXI+PC9uZy1jb250YWluZXI+XHJcbiAgYFxyXG59KVxyXG4vLyBBIGJhc2ljIGNvbXBvbmVudCB0aGF0IHVzZXMgdGhlIENyZWF0ZUZsb3dTZXJ2aWNlIHRvIGdlbmVyYXRlIGFuZCBkaXNwbGF5IHRoZSBub2Rlc1xyXG4vLyBiYXNlZCBvbiB0aGUgY29udGVudCBwcm92aWRlZCBpbiB0aGVzZSBpbnB1dHMuXHJcbmV4cG9ydCBjbGFzcyBOZ1RleHRmbG93Q29tcG9uZW50IHtcclxuICBAVmlld0NoaWxkKCd2aWV3Q29udGFpbmVyJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmfSkgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcclxuICBASW5wdXQoKSBub2RlU3R5bGVzOiBhbnkgPSB7fTtcclxuICBASW5wdXQoKSBmaXJzdE9uVG9wOiBib29sZWFuID0gdHJ1ZTtcclxuICBASW5wdXQoKSBzaG93UGFnZU51bWJlcnM6IGJvb2xlYW47XHJcbiAgQElucHV0KCkgaXNPdmVybGFpZDogYm9vbGVhbjtcclxuICBcclxuICAvLyBDb250ZW50IGNoYW5nZSBoYW5kbGluZy5cclxuICBwcml2YXRlIF9jb250ZW50OiBzdHJpbmc7XHJcbiAgZ2V0IGNvbnRlbnQoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH1cclxuICBASW5wdXQoKSBzZXQgY29udGVudCh0ZXh0OiBzdHJpbmcpIHtcclxuICAgIHRoaXMuX2NvbnRlbnQgPSB0ZXh0O1xyXG4gICAgLy8gQ2xlYXIgdGhlIG5vZGVzIG91dCBvZiB0aGUgTm9kZUNvbXBvbmVudFtdIGFycmF5LlxyXG4gICAgdGhpcy5ub2RlU2VydmljZS5jbGVhck5vZGVzKCk7XHJcbiAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcclxuICAgIHRoaXMubm9kZVNlcnZpY2UuY3JlYXRlRmxvdyh0aGlzLmNvbnRlbnQsIHRoaXMudmlld0NvbnRhaW5lciwgdGhpcy5ub2RlU3R5bGVzLCB0aGlzLnNob3dQYWdlTnVtYmVycywgdGhpcy5pc092ZXJsYWlkKTsgICAgXHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGVTZXJ2aWNlOiBDcmVhdGVGbG93U2VydmljZSkge1xyXG4gICAgbm9kZVNlcnZpY2UuZmlyc3RPblRvcCA9IHRoaXMuZmlyc3RPblRvcDtcclxuICB9IFxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG4vLyBNb2R1bGUgY29tcG9uZW50c1xyXG5pbXBvcnQgeyBOZ1RleHRmbG93Q29tcG9uZW50IH0gZnJvbSAnLi9uZy10ZXh0Zmxvdy5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBOb2RlQ29tcG9uZW50IH0gZnJvbSAnLi9ub2RlLmNvbXBvbmVudCc7XHJcblxyXG4vLyBTZXJ2aWNlc1xyXG5pbXBvcnQgeyBDcmVhdGVGbG93U2VydmljZSB9IGZyb20gJy4vY3JlYXRlLWZsb3cuc2VydmljZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG4gIGRlY2xhcmF0aW9uczogW05nVGV4dGZsb3dDb21wb25lbnQsIE5vZGVDb21wb25lbnRdLFxyXG4gIGVudHJ5Q29tcG9uZW50czogW05vZGVDb21wb25lbnRdLFxyXG4gIGV4cG9ydHM6IFtOZ1RleHRmbG93Q29tcG9uZW50XVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmdUZXh0Zmxvd01vZHVsZSB7XHJcblxyXG4gIHB1YmxpYyBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogTmdUZXh0Zmxvd01vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbIENyZWF0ZUZsb3dTZXJ2aWNlIF1cclxuICAgIH1cclxuICB9XHJcblxyXG4gfVxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7O0lBOEdFLFlBQW9CLFFBQW1CLEVBQVUsVUFBc0I7UUFBbkQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLGVBQVUsR0FBVixVQUFVLENBQVk7d0JBeEQ1QyxFQUFFOzBCQUNDLEtBQUs7Z0NBQ0MsS0FBSzsyQkFJbEIsSUFBSTs7NEJBT21CLEVBQUU7OEJBQ0UsUUFBUTs7MkJBR3ZDLEVBQUU7NEJBQ0QsRUFBRTt5QkFDTCxFQUFFO3lCQUNGLEVBQUU7NkJBR0s7WUFDdEIsU0FBUyxFQUFFLEVBQUU7WUFDYixZQUFZLEVBQUU7Z0JBQ1osUUFBUSxFQUFFLEtBQUs7Z0JBQ2YsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCLFVBQVUsRUFBRSxNQUFNO2dCQUNsQixhQUFhLEVBQUUsS0FBSztnQkFDcEIsV0FBVyxFQUFFLFNBQVM7Z0JBQ3RCLFlBQVksRUFBRSxPQUFPO2dCQUNyQixlQUFlLEVBQUUsV0FBVzthQUM3QjtZQUNELFlBQVksRUFBRTtnQkFDWixXQUFXLEVBQUUsTUFBTTtnQkFDbkIsUUFBUSxFQUFFLE1BQU07YUFDakI7WUFDRCxX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