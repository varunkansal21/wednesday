{"version":3,"sources":["ng://ng-textflow/ng-textflow/node.component.ts","ng://ng-textflow/ng-textflow/create-flow.service.ts","ng://ng-textflow/ng-textflow/ng-textflow.component.ts","ng://ng-textflow/ng-textflow/ng-textflow.module.ts"],"names":["NodeComponent","renderer","elementRef","this","hostStyle","contentStyle","height","width","fontSize","wordSpacing","textAlign","lineHeight","leftAlignLast","headingStyle","font-size","numberStyle","Subject","prototype","ngOnInit","_this","dummyText","text","trimming","changes","MutationObserver","mutations","manageState","observe","dummyDivRef","nativeElement","attributes","childList","characterData","setTimeout","index","Object","defineProperty","textContent","content","_isVisible","value","hostVisibility","_index","pageNumber","Math","abs","setStyle","parseInt","mask","style","replace","_heading","heading","headingChangedSubject","next","_pageNumberAtTop","pageNumberAtTop","padding","applyStyle","nodeStyle","convertStyleToPx","defaultStyles","overflow","isOverlaid","hostPosition","tempStyle","parseFloat","key","indexOf","round","parseLineHeight","textDivRef","compareDivs","dummyLines","floor","clientHeight","lines","diffLines","words","split","length","count","adding","finishing","console","log","trim","addword","finish","comps","wordsToRemove","slice","join","finishedSubject","overflowSubject","pipe","debounce","interval","Component","args","selector","template","Renderer2","ElementRef","ViewChild","HostBinding","CreateFlowService","injector","resolver","Array","BehaviorSubject","nodeFactory","resolveComponentFactory","finishedSubscription","finished","subscribe","nodeList","forEach","node","isVisible","headingChangedSubscription","headingChanged","showHeading","nodesSubject","clearNodes","createFlow","textPassage","location","showPageNumbers","createNode","overFlowSubscriptions","push","overflowText","nodeRef","ViewContainerRef","createComponent","undefined","create","instance","showPageNumber","firstOnTop","ngOnDestroy","unsubscribe","subscription","Injectable","Injector","ComponentFactoryResolver","NgTextflowComponent","nodeService","_content","viewContainer","clear","nodeStyles","read","Input","NgTextflowModule","forRoot","ngModule","providers","NgModule","imports","CommonModule","declarations","entryComponents","exports"],"mappings":"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","sourcesContent":["import { Component, OnInit, ElementRef, ViewChild, Renderer2, OnDestroy, HostBinding } from '@angular/core';\r\nimport { Observable, Subject, interval } from 'rxjs';\r\nimport { debounce } from 'rxjs/operators';\r\n\r\n// @dynamic\r\n@Component({\r\n  selector: 'app-node',\r\n  template: `\r\n    <div class=\"mask\" #maskTag [ngStyle]=\"hostStyle\">\r\n      <div *ngIf=\"showPageNumber && pageNumberAtTop\" [ngStyle]=\"numberStyle\">\r\n        {{pageNumber}}\r\n      </div>  \r\n      <div *ngIf=\"showHeading\" [ngStyle]=\"headingStyle\">\r\n        {{heading}}\r\n      </div>\r\n      <div #textref [ngStyle]=\"nodeStyle\" class=\"content\">\r\n        {{text}}\r\n        <div #dummy class=\"dummy\" >{{ dummyText }}</div>\r\n      </div>\r\n      <div *ngIf=\"showPageNumber && !pageNumberAtTop\" [ngStyle]=\"numberStyle\">\r\n        {{pageNumber}}\r\n      </div>\r\n    </div>\r\n`,\r\n  styles: [`\r\n    .content {\r\n      position: relative;\r\n      text-align-last: justify;\r\n      cursor: default;\r\n    }\r\n    .mask {\r\n      display block;\r\n      overflow: hidden;\r\n    }\r\n    :host {\r\n      display: block;\r\n      overflow: hidden;\r\n      user-select: none;\r\n    }\r\n    .dummy {\r\n      position: absolute;\r\n      background-color: rgba(155, 255, 155, 0.4);\r\n      left: 0px;\r\n      top: 0px;\r\n      visibility: hidden;\r\n    }\r\n  `]\r\n})\r\nexport class NodeComponent implements OnInit {\r\n  @ViewChild('textref') private textDivRef: ElementRef;\r\n  @ViewChild('dummy')  private dummyDivRef: ElementRef;\r\n  @ViewChild('maskTag') private mask: ElementRef;\r\n\r\n  private _index: number;  \r\n  private _heading: string = '';\r\n  private _isVisible: boolean = false;\r\n  private _pageNumberAtTop: boolean = false;\r\n  private changes: MutationObserver;\r\n  private padding: number;\r\n  \r\n  showHeading: boolean = true;\r\n  text: string;\r\n  showPageNumber: boolean;\r\n  isOverlaid: boolean;\r\n  pageNumber: number;\r\n\r\n  // Get host properties to dynamically change.\r\n  @HostBinding('style.position') hostPosition = '';\r\n  @HostBinding('style.visibility') hostVisibility = 'hidden';\r\n\r\n  // Dynamic styles.\r\n  numberStyle: any = {};\r\n  headingStyle: any = {};\r\n  nodeStyle: any = {};\r\n  hostStyle: any = {};\r\n\r\n  // Default style incase there is none supplied.\r\n  private defaultStyles = {\r\n    hostStyle: {},\r\n    contentStyle: {\r\n      'height': '9em',\r\n      'width': '200px',\r\n      'fontSize': '11px',\r\n      'wordSpacing': '2px',\r\n      'textAlign': 'justify',\r\n      'lineHeight': '1.1em',\r\n      'leftAlignLast': 'justified'\r\n    },\r\n    headingStyle: {\r\n      'font-size': '14px',\r\n      'height': '25px'\r\n    },\r\n    numberStyle: {\r\n      'font-size': '10px',\r\n    }\r\n  }; \r\n\r\n  // More text to put into nodes, so overflow.\r\n  private overflowSubject: Subject<string> = new Subject();\r\n  overflow: Observable<string> = this.overflowSubject as Observable<string>;\r\n\r\n  // Last node complete.\r\n  private static finishedSubject: Subject<null> = new Subject();\r\n  static finished: Observable<null> = NodeComponent.finishedSubject as Observable<null>;\r\n\r\n  // Heading has changed.\r\n  private static headingChangedSubject: Subject<null> = new Subject();\r\n  static headingChanged: Observable<null> = NodeComponent.headingChangedSubject.pipe(debounce(() => interval(10)));\r\n\r\n  // Inject services.\r\n  constructor(private renderer: Renderer2, private elementRef: ElementRef) { };\r\n\r\n  ngOnInit() {    \r\n    // Some initialisation.\r\n    this.dummyText = this.text;\r\n    this.trimming = true;\r\n\r\n    // We use the mutation observer to see when our dummy text change has happened.\r\n    this.changes = new MutationObserver((mutations: MutationRecord[]) => this.manageState());\r\n    this.changes.observe(this.dummyDivRef.nativeElement, { attributes: true, childList: true, characterData: true });\r\n\r\n    // Kick off the state machine here, but with a delay for the first node,\r\n    // since the initial loading of the component causes some delay in other initialisation. (I think).\r\n    setTimeout(() => { // Wait till index is resolved.\r\n      // We need to pause for the first node since the loading is lazy?\r\n      if (this.index >= 99) {\r\n        setTimeout(() => this.manageState(), 200); // TODO: find a event driven method here.\r\n      } else {\r\n        // The following nodes do not need this delay.\r\n        this.manageState();\r\n      }\r\n    })\r\n  }\r\n\r\n  // Some getter/setter methods.\r\n  get dummyText(): string { return this.dummyDivRef.nativeElement.textContent; }\r\n  set dummyText(content: string) { this.dummyDivRef.nativeElement.textContent = content; }\r\n  \r\n  get isVisible(): boolean { return this._isVisible; }\r\n  set isVisible(value: boolean) {\r\n    this._isVisible = value;\r\n    this.hostVisibility = 'visible';\r\n  }\r\n\r\n  get index(): number { return this._index; }\r\n  set index(index: number) {\r\n    this.pageNumber = 100 - index;\r\n    setTimeout(() => {\r\n      this._index = Math.abs(index);\r\n      this.renderer.setStyle(this.elementRef.nativeElement, 'z-index', index); \r\n    });\r\n  }\r\n\r\n  get width(): number { return parseInt(this.mask.nativeElement.style.width.replace(/\\D/g, '')) }\r\n  set width(width: number) { this.renderer.setStyle(this.mask.nativeElement, 'width', `${width}px`) }\r\n  \r\n  get heading(): string { return this._heading; }\r\n  set heading(heading: string) { \r\n    this._heading = heading === '' ? this._heading = ' ' : this._heading = heading;\r\n    NodeComponent.headingChangedSubject.next();\r\n  }\r\n\r\n  get pageNumberAtTop(): boolean { return this._pageNumberAtTop; }\r\n  set pageNumberAtTop(value: boolean) {\r\n    this._pageNumberAtTop = value;\r\n    this.numberStyle['padding-bottom'] = this.pageNumberAtTop ? '0px' : `${this.padding}px`;\r\n    this.numberStyle['padding-top'] = this.pageNumberAtTop ? `${this.padding}px` : '0px';\r\n  }\r\n\r\n  // Apply the style to the current node. Assumes the correct attributes are contained.\r\n  applyStyle(style: any) {\r\n    this.nodeStyle = style.contentStyle ? this.convertStyleToPx(style.contentStyle) : this.convertStyleToPx(this.defaultStyles.contentStyle);\r\n    this.numberStyle = style.numberStyle ? style.numberStyle : this.defaultStyles.numberStyle;\r\n    this.hostStyle = style.hostStyle ? style.hostStyle : this.defaultStyles.hostStyle;\r\n    // Let's manipulate the padding style that was added to manage top or bottom placed numbering.\r\n    if (this.numberStyle.padding > '') {\r\n      this.padding = parseInt(this.numberStyle.padding.replace(/\\D/g, ''));\r\n    } else {\r\n      this.padding = 16;\r\n    }\r\n    this.numberStyle['padding-left'] = `${parseInt(this.nodeStyle.width.replace(/\\D/g, ''))/2}px`;\r\n    this.headingStyle = style.headingStyle ? style.headingStyle : this.defaultStyles.headingStyle;\r\n    this.headingStyle.width = this.nodeStyle.width;\r\n    this.renderer.setStyle(this.elementRef.nativeElement, 'width', style.width);\r\n    this.nodeStyle.overflow = 'hidden';\r\n    this.width = parseInt(this.nodeStyle.width.replace(/\\D/g, ''));\r\n    if (this.isOverlaid) {\r\n      this.hostPosition = 'absolute';\r\n    }\r\n  }\r\n\r\n  // Helper function to get em values into px values for simpler calculation later.\r\n  private convertStyleToPx(style: any): any {\r\n    let tempStyle = style;\r\n    // Get the fontSize of the style.\r\n    let fontSizeSuffix: string = tempStyle['fontSize'].replace(/[\\d\\.]/g, '');\r\n    let fontSize: number = parseFloat(tempStyle['fontSize'].replace(/[A-Za-z]/g,''));\r\n    \r\n    for (let key in tempStyle) {\r\n      // Not we need to check each value only, for em, pt, px etc..\r\n      if ((<string>tempStyle[key]).indexOf('em') > 0) {\r\n        let suffix = tempStyle[key].replace(/[\\d\\.]/g, '');\r\n        switch(suffix) {\r\n          case 'em': {\r\n            // Convert em value to px\r\n            let value: number = parseFloat(tempStyle[key].replace(/[A-Za-z]/g,''));\r\n            tempStyle[key] = `${Math.round(value*fontSize)}px`\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return tempStyle;\r\n  }\r\n\r\n  // Gets the lineHeight of the current node so we can do other trimming calculations.\r\n  private parseLineHeight(): number {\r\n    let lineHeight: string = this.textDivRef.nativeElement.style.lineHeight;\r\n    return parseInt(lineHeight.replace(/\\D/g, ''));\r\n  }\r\n  \r\n  // Produces a set of data about the current dummy div compated to the content div.\r\n  private compareDivs(): { 'lines': number, 'diffLines': number, 'words': number } {\r\n    let lineHeight = this.parseLineHeight();\r\n    let dummyLines = Math.floor(this.dummyDivRef.nativeElement.clientHeight / lineHeight);\r\n    let contentLines = Math.floor(this.textDivRef.nativeElement.clientHeight / lineHeight);\r\n    let dummyTextWordCount = this.dummyText.split(' ').length;\r\n\r\n    return {\r\n      'lines': dummyLines,\r\n      'diffLines': dummyLines - contentLines,\r\n      'words': dummyTextWordCount\r\n    };\r\n  }\r\n\r\n  // ------------------------ Trim loop test. -----------------------\r\n  //\r\n  // This is a small state machine to process the trimming algorithm.\r\n  //\r\n  private adding: boolean = false;\r\n  private finishing: boolean = false;\r\n  private trimming: boolean = false;\r\n  \r\n  private count: number = 100;\r\n\r\n  private manageState() {\r\n    // Protect against infinite loop.\r\n    if (this.count-- <= 0 ) {\r\n      this.trimming = false;\r\n      this.adding = false;\r\n      this.finishing = false;\r\n      console.log('ERROR - loop count > 100');\r\n    }\r\n    if (this.trimming) {\r\n      this.trim();\r\n    } else if (this.adding) {\r\n      this.addword();\r\n    } else if (this.finishing) {\r\n      this.finish();\r\n    }\r\n  }\r\n\r\n  private trim() {\r\n    let comps = this.compareDivs();\r\n    let wordsToRemove = Math.floor(comps.words/comps.lines) * (comps.diffLines + 1);\r\n    if (wordsToRemove > 0) {\r\n      this.dummyText = this.dummyText.split(' ').slice(0, comps.words - wordsToRemove).join(' ');\r\n    } else {\r\n      this.trimming = false;\r\n      this.adding = true;\r\n      this.addword();\r\n    }\r\n  }\r\n\r\n  private addword() {\r\n    let comps = this.compareDivs();\r\n    if (comps.diffLines <= -1) {\r\n      if (this.dummyText.length < this.text.length) {\r\n        this.dummyText = this.dummyText + ' ' + this.text.split(' ')[comps.words];\r\n      } else {\r\n        // This is the last node.\r\n        this.renderer.setStyle(this.textDivRef.nativeElement, 'textAlignLast', 'left');\r\n        NodeComponent.finishedSubject.next();\r\n      }\r\n    } else {\r\n      // Take off the last word again.\r\n      this.dummyText = this.dummyText.split(' ').slice(0, comps.words - 1).join(' ');\r\n      this.adding = false;\r\n      this.finishing = true;        \r\n    }\r\n  }\r\n\r\n  private finish() {\r\n    let comps = this.compareDivs();\r\n    let lastword: string[] = this.dummyText.split(' ');\r\n    let overflowArray = this.text.split(' ');\r\n    let overflow = overflowArray.slice(this.dummyText.split(' ').length).join(' ');\r\n    this.text = this.dummyText;\r\n    this.finishing = false;\r\n    this.overflowSubject.next(overflow);\r\n  }\r\n\r\n}\r\n","import { Injectable, Injector, ComponentFactoryResolver,\r\n         ComponentFactory, ViewContainerRef, ComponentRef, OnDestroy } from '@angular/core';\r\nimport { NodeComponent } from './node.component';\r\nimport { BehaviorSubject, Subject, Observable, Subscription } from 'rxjs';\r\n\r\n@Injectable()\r\nexport class CreateFlowService implements OnDestroy {\r\n  private nodeList: NodeComponent[] = new Array<NodeComponent>();\r\n  private nodeFactory: ComponentFactory<NodeComponent>;\r\n  firstOnTop: boolean = true;\r\n\r\n  // Subscriptions\r\n  private finishedSubscription: Subscription; // For when the nodes are complete.\r\n  private headingChangedSubscription: Subscription; // For when the heading is externally changed.\r\n  private overFlowSubscriptions: Subscription[] = []; // During generation of nodes, fires when there are more nodes to generate.\r\n\r\n  // Provide an array of nodes once the generation is complete.\r\n  private nodesSubject: Subject<NodeComponent[]> = new BehaviorSubject<NodeComponent[]>(null);\r\n  nodes: Observable<NodeComponent[]> = this.nodesSubject as Observable<NodeComponent[]>;\r\n\r\n  constructor(private injector: Injector, private resolver: ComponentFactoryResolver) {\r\n    this.nodeFactory = this.resolver.resolveComponentFactory(NodeComponent);\r\n    \r\n    // When all nodes are finished generating, do some housework.\r\n    this.finishedSubscription =  NodeComponent.finished.subscribe(() => {\r\n      this.nodeList.forEach(node =>  node.isVisible = true); // Make all visible once complete.\r\n\r\n      // If headings are modified externally, then update sibling nodes to maintain consistent formating.\r\n      this.headingChangedSubscription = NodeComponent.headingChanged.subscribe(() => {\r\n        // Loop once to see if all are empty.\r\n        let count = 0;\r\n        this.nodeList.forEach(node => { \r\n          count = node.heading <= ' ' ? count + 1 : count - 1;\r\n        });\r\n\r\n        // Loop again to update the visibility of the headings.\r\n        this.nodeList.forEach(node => {\r\n          node.showHeading = count === this.nodeList.length ? false : true;\r\n        });\r\n      });\r\n\r\n      // Make list of nodes available once all are complete.\r\n      this.nodesSubject.next(this.nodeList);\r\n    });\r\n  } \r\n\r\n  clearNodes() {\r\n    this.nodeList = [];\r\n  }\r\n\r\n  // This will kick off a process that generates a node every time a generated node is too full and overflows with text.\r\n  createFlow(textPassage: string, \r\n             location: ViewContainerRef, \r\n             style: any, \r\n             showPageNumbers: boolean, \r\n             isOverlaid: boolean) {\r\n\r\n    let node: NodeComponent = this.createNode(textPassage, location, style, showPageNumbers, isOverlaid);\r\n    \r\n    // Create a new node if there is any overflow text from last node generated.\r\n    // Last node will know when it is the last one, and will \r\n    this.overFlowSubscriptions.push(node.overflow.subscribe(overflowText => {\r\n      if (overflowText) {\r\n        this.createFlow(overflowText, location, style, showPageNumbers, isOverlaid);\r\n      }\r\n    }));\r\n  }\r\n\r\n  private createNode(content: string,\r\n                     location?: ViewContainerRef, \r\n                     style?: any, showPageNumbers?: \r\n                     boolean, isOverlaid?: boolean): NodeComponent {\r\n                       \r\n    // Generate the node with the nodeFactory.\r\n    let nodeRef: ComponentRef<NodeComponent>;\r\n    if (location || location instanceof ViewContainerRef) {\r\n      nodeRef = location.createComponent(this.nodeFactory, undefined, this.injector);\r\n    } else {\r\n      nodeRef = this.nodeFactory.create(this.injector);\r\n    }\r\n    \r\n    // Update the node\r\n    nodeRef.instance.isOverlaid = isOverlaid;\r\n    nodeRef.instance.showPageNumber = showPageNumbers;\r\n    nodeRef.instance.text = content;\r\n    if (style) {\r\n      nodeRef.instance.applyStyle(style);\r\n    }\r\n    \r\n    // Add node to list of nodes and update its index value.\r\n    this.nodeList.push(nodeRef.instance);\r\n    nodeRef.instance.index = this.firstOnTop ? 100-this.nodeList.length : this.nodeList.length;\r\n\r\n    return nodeRef.instance;\r\n  }\r\n\r\n  // Tidy up subscriptions.\r\n  ngOnDestroy() {\r\n    this.finishedSubscription.unsubscribe();\r\n    this.headingChangedSubscription.unsubscribe();\r\n    this.overFlowSubscriptions.forEach(subscription => {\r\n      subscription.unsubscribe();\r\n    });\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  ViewChild, \r\n  ViewContainerRef,\r\n  Input} from '@angular/core';\r\nimport { CreateFlowService } from './create-flow.service';\r\n\r\n@Component({\r\n  selector: 'ng-textflow',\r\n  template: ` \r\n    <ng-container #viewContainer></ng-container>\r\n  `\r\n})\r\n// A basic component that uses the CreateFlowService to generate and display the nodes\r\n// based on the content provided in these inputs.\r\nexport class NgTextflowComponent {\r\n  @ViewChild('viewContainer', { read: ViewContainerRef}) viewContainer: ViewContainerRef;\r\n  @Input() nodeStyles: any = {};\r\n  @Input() firstOnTop: boolean = true;\r\n  @Input() showPageNumbers: boolean;\r\n  @Input() isOverlaid: boolean;\r\n  \r\n  // Content change handling.\r\n  private _content: string;\r\n  get content(): string { return this._content; }\r\n  @Input() set content(text: string) {\r\n    this._content = text;\r\n    // Clear the nodes out of the NodeComponent[] array.\r\n    this.nodeService.clearNodes();\r\n    this.viewContainer.clear();\r\n    this.nodeService.createFlow(this.content, this.viewContainer, this.nodeStyles, this.showPageNumbers, this.isOverlaid);    \r\n  }\r\n\r\n  constructor(private nodeService: CreateFlowService) {\r\n    nodeService.firstOnTop = this.firstOnTop;\r\n  } \r\n}\r\n","import { NgModule, ModuleWithProviders } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\n\r\n// Module components\r\nimport { NgTextflowComponent } from './ng-textflow.component';\r\nimport { NodeComponent } from './node.component';\r\n\r\n// Services\r\nimport { CreateFlowService } from './create-flow.service';\r\n\r\n@NgModule({\r\n  imports: [CommonModule],\r\n  declarations: [NgTextflowComponent, NodeComponent],\r\n  entryComponents: [NodeComponent],\r\n  exports: [NgTextflowComponent]\r\n})\r\nexport class NgTextflowModule {\r\n\r\n  public static forRoot(): ModuleWithProviders {\r\n\r\n    return {\r\n      ngModule: NgTextflowModule,\r\n      providers: [ CreateFlowService ]\r\n    }\r\n  }\r\n\r\n }\r\n"]}